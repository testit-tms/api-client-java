/*
 * API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package ru.testit.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.openapitools.jackson.nullable.JsonNullable;
import ru.testit.client.model.AttachmentModel;
import ru.testit.client.model.LinkModel;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import ru.testit.client.invoker.JSON;

/**
 * TestResultHistoryResponse
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.11.0")
public class TestResultHistoryResponse {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nonnull
  private UUID id;

  public static final String SERIALIZED_NAME_CREATED_DATE = "createdDate";
  @SerializedName(SERIALIZED_NAME_CREATED_DATE)
  @javax.annotation.Nonnull
  private OffsetDateTime createdDate;

  public static final String SERIALIZED_NAME_MODIFIED_DATE = "modifiedDate";
  @SerializedName(SERIALIZED_NAME_MODIFIED_DATE)
  @javax.annotation.Nonnull
  private OffsetDateTime modifiedDate;

  public static final String SERIALIZED_NAME_USER_ID = "userId";
  @SerializedName(SERIALIZED_NAME_USER_ID)
  @javax.annotation.Nonnull
  private UUID userId;

  public static final String SERIALIZED_NAME_TEST_RUN_ID = "testRunId";
  @SerializedName(SERIALIZED_NAME_TEST_RUN_ID)
  @javax.annotation.Nullable
  private UUID testRunId;

  public static final String SERIALIZED_NAME_TEST_RUN_NAME = "testRunName";
  @SerializedName(SERIALIZED_NAME_TEST_RUN_NAME)
  @javax.annotation.Nullable
  private String testRunName;

  public static final String SERIALIZED_NAME_CREATED_BY_USER_NAME = "createdByUserName";
  @SerializedName(SERIALIZED_NAME_CREATED_BY_USER_NAME)
  @javax.annotation.Nullable
  private String createdByUserName;

  public static final String SERIALIZED_NAME_TEST_PLAN_ID = "testPlanId";
  @SerializedName(SERIALIZED_NAME_TEST_PLAN_ID)
  @javax.annotation.Nullable
  private UUID testPlanId;

  public static final String SERIALIZED_NAME_TEST_PLAN_GLOBAL_ID = "testPlanGlobalId";
  @SerializedName(SERIALIZED_NAME_TEST_PLAN_GLOBAL_ID)
  @javax.annotation.Nullable
  private Long testPlanGlobalId;

  public static final String SERIALIZED_NAME_TEST_PLAN_NAME = "testPlanName";
  @SerializedName(SERIALIZED_NAME_TEST_PLAN_NAME)
  @javax.annotation.Nullable
  private String testPlanName;

  public static final String SERIALIZED_NAME_CONFIGURATION_NAME = "configurationName";
  @SerializedName(SERIALIZED_NAME_CONFIGURATION_NAME)
  @javax.annotation.Nullable
  private String configurationName;

  public static final String SERIALIZED_NAME_IS_AUTOMATED = "isAutomated";
  @SerializedName(SERIALIZED_NAME_IS_AUTOMATED)
  @javax.annotation.Nonnull
  private Boolean isAutomated;

  public static final String SERIALIZED_NAME_OUTCOME = "outcome";
  @SerializedName(SERIALIZED_NAME_OUTCOME)
  @javax.annotation.Nullable
  private String outcome;

  public static final String SERIALIZED_NAME_COMMENT = "comment";
  @SerializedName(SERIALIZED_NAME_COMMENT)
  @javax.annotation.Nullable
  private String comment;

  public static final String SERIALIZED_NAME_LINKS = "links";
  @SerializedName(SERIALIZED_NAME_LINKS)
  @javax.annotation.Nullable
  private List<LinkModel> links;

  public static final String SERIALIZED_NAME_STARTED_ON = "startedOn";
  @SerializedName(SERIALIZED_NAME_STARTED_ON)
  @javax.annotation.Nullable
  private OffsetDateTime startedOn;

  public static final String SERIALIZED_NAME_COMPLETED_ON = "completedOn";
  @SerializedName(SERIALIZED_NAME_COMPLETED_ON)
  @javax.annotation.Nullable
  private OffsetDateTime completedOn;

  public static final String SERIALIZED_NAME_DURATION = "duration";
  @SerializedName(SERIALIZED_NAME_DURATION)
  @javax.annotation.Nullable
  private Long duration;

  public static final String SERIALIZED_NAME_CREATED_BY_ID = "createdById";
  @SerializedName(SERIALIZED_NAME_CREATED_BY_ID)
  @javax.annotation.Nonnull
  private UUID createdById;

  public static final String SERIALIZED_NAME_MODIFIED_BY_ID = "modifiedById";
  @SerializedName(SERIALIZED_NAME_MODIFIED_BY_ID)
  @javax.annotation.Nullable
  private UUID modifiedById;

  public static final String SERIALIZED_NAME_ATTACHMENTS = "attachments";
  @SerializedName(SERIALIZED_NAME_ATTACHMENTS)
  @javax.annotation.Nullable
  private List<AttachmentModel> attachments;

  public static final String SERIALIZED_NAME_WORK_ITEM_VERSION_ID = "workItemVersionId";
  @SerializedName(SERIALIZED_NAME_WORK_ITEM_VERSION_ID)
  @javax.annotation.Nullable
  private UUID workItemVersionId;

  public static final String SERIALIZED_NAME_WORK_ITEM_VERSION_NUMBER = "workItemVersionNumber";
  @SerializedName(SERIALIZED_NAME_WORK_ITEM_VERSION_NUMBER)
  @javax.annotation.Nullable
  private Integer workItemVersionNumber;

  public static final String SERIALIZED_NAME_LAUNCH_SOURCE = "launchSource";
  @SerializedName(SERIALIZED_NAME_LAUNCH_SOURCE)
  @javax.annotation.Nullable
  private String launchSource;

  public static final String SERIALIZED_NAME_FAILURE_CLASS_IDS = "failureClassIds";
  @SerializedName(SERIALIZED_NAME_FAILURE_CLASS_IDS)
  @javax.annotation.Nonnull
  private List<UUID> failureClassIds = new ArrayList<>();

  public static final String SERIALIZED_NAME_PARAMETERS = "parameters";
  @SerializedName(SERIALIZED_NAME_PARAMETERS)
  @javax.annotation.Nullable
  private Map<String, String> parameters;

  public TestResultHistoryResponse() {
  }

  public TestResultHistoryResponse id(@javax.annotation.Nonnull UUID id) {
    this.id = id;
    return this;
  }

  /**
   * Internal test result identifier
   * @return id
   */
  @javax.annotation.Nonnull
  public UUID getId() {
    return id;
  }

  public void setId(@javax.annotation.Nonnull UUID id) {
    this.id = id;
  }


  public TestResultHistoryResponse createdDate(@javax.annotation.Nonnull OffsetDateTime createdDate) {
    this.createdDate = createdDate;
    return this;
  }

  /**
   * Test result creation date
   * @return createdDate
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getCreatedDate() {
    return createdDate;
  }

  public void setCreatedDate(@javax.annotation.Nonnull OffsetDateTime createdDate) {
    this.createdDate = createdDate;
  }


  public TestResultHistoryResponse modifiedDate(@javax.annotation.Nonnull OffsetDateTime modifiedDate) {
    this.modifiedDate = modifiedDate;
    return this;
  }

  /**
   * Test result last modification date
   * @return modifiedDate
   */
  @javax.annotation.Nonnull
  public OffsetDateTime getModifiedDate() {
    return modifiedDate;
  }

  public void setModifiedDate(@javax.annotation.Nonnull OffsetDateTime modifiedDate) {
    this.modifiedDate = modifiedDate;
  }


  public TestResultHistoryResponse userId(@javax.annotation.Nonnull UUID userId) {
    this.userId = userId;
    return this;
  }

  /**
   * Internal identifier of user who stopped test run related to the test result or user who created the test result                If test run was stopped, this property equals identifier of user who stopped it.  Otherwise, the property equals identifier of user who created the test result
   * @return userId
   */
  @javax.annotation.Nonnull
  public UUID getUserId() {
    return userId;
  }

  public void setUserId(@javax.annotation.Nonnull UUID userId) {
    this.userId = userId;
  }


  public TestResultHistoryResponse testRunId(@javax.annotation.Nullable UUID testRunId) {
    this.testRunId = testRunId;
    return this;
  }

  /**
   * Identifier of test run related to the test result
   * @return testRunId
   */
  @javax.annotation.Nullable
  public UUID getTestRunId() {
    return testRunId;
  }

  public void setTestRunId(@javax.annotation.Nullable UUID testRunId) {
    this.testRunId = testRunId;
  }


  public TestResultHistoryResponse testRunName(@javax.annotation.Nullable String testRunName) {
    this.testRunName = testRunName;
    return this;
  }

  /**
   * Name of test run related to the test result
   * @return testRunName
   */
  @javax.annotation.Nullable
  public String getTestRunName() {
    return testRunName;
  }

  public void setTestRunName(@javax.annotation.Nullable String testRunName) {
    this.testRunName = testRunName;
  }


  public TestResultHistoryResponse createdByUserName(@javax.annotation.Nullable String createdByUserName) {
    this.createdByUserName = createdByUserName;
    return this;
  }

  /**
   * Username of user who created test run
   * @return createdByUserName
   */
  @javax.annotation.Nullable
  public String getCreatedByUserName() {
    return createdByUserName;
  }

  public void setCreatedByUserName(@javax.annotation.Nullable String createdByUserName) {
    this.createdByUserName = createdByUserName;
  }


  public TestResultHistoryResponse testPlanId(@javax.annotation.Nullable UUID testPlanId) {
    this.testPlanId = testPlanId;
    return this;
  }

  /**
   * Internal identifier of test plan related to the test result&#39;s test run
   * @return testPlanId
   */
  @javax.annotation.Nullable
  public UUID getTestPlanId() {
    return testPlanId;
  }

  public void setTestPlanId(@javax.annotation.Nullable UUID testPlanId) {
    this.testPlanId = testPlanId;
  }


  public TestResultHistoryResponse testPlanGlobalId(@javax.annotation.Nullable Long testPlanGlobalId) {
    this.testPlanGlobalId = testPlanGlobalId;
    return this;
  }

  /**
   * Global identifier of test plan related to the test result&#39;s test run
   * @return testPlanGlobalId
   */
  @javax.annotation.Nullable
  public Long getTestPlanGlobalId() {
    return testPlanGlobalId;
  }

  public void setTestPlanGlobalId(@javax.annotation.Nullable Long testPlanGlobalId) {
    this.testPlanGlobalId = testPlanGlobalId;
  }


  public TestResultHistoryResponse testPlanName(@javax.annotation.Nullable String testPlanName) {
    this.testPlanName = testPlanName;
    return this;
  }

  /**
   * Name of test plan related to the test result&#39;s test run
   * @return testPlanName
   */
  @javax.annotation.Nullable
  public String getTestPlanName() {
    return testPlanName;
  }

  public void setTestPlanName(@javax.annotation.Nullable String testPlanName) {
    this.testPlanName = testPlanName;
  }


  public TestResultHistoryResponse configurationName(@javax.annotation.Nullable String configurationName) {
    this.configurationName = configurationName;
    return this;
  }

  /**
   * Configuration name of test point related to the test result or from test result itself                If test point related to the test result has configuration, this property will be equal to the test point configuration name.  Otherwise, this property will be equal to the test result configuration name
   * @return configurationName
   */
  @javax.annotation.Nullable
  public String getConfigurationName() {
    return configurationName;
  }

  public void setConfigurationName(@javax.annotation.Nullable String configurationName) {
    this.configurationName = configurationName;
  }


  public TestResultHistoryResponse isAutomated(@javax.annotation.Nonnull Boolean isAutomated) {
    this.isAutomated = isAutomated;
    return this;
  }

  /**
   * Boolean flag defines if test point related to the test result is automated or not
   * @return isAutomated
   */
  @javax.annotation.Nonnull
  public Boolean getIsAutomated() {
    return isAutomated;
  }

  public void setIsAutomated(@javax.annotation.Nonnull Boolean isAutomated) {
    this.isAutomated = isAutomated;
  }


  public TestResultHistoryResponse outcome(@javax.annotation.Nullable String outcome) {
    this.outcome = outcome;
    return this;
  }

  /**
   * Outcome from test result with max modified date or from first created test result                Property can contain one of these values: Passed, Failed, InProgress, Blocked, Skipped.                If any test result related to the test run is linked with autotest and the run has an outcome, the outcome value equals to the  worst outcome of the last modified test result. Otherwise, the outcome equals to the outcome of first created test result in the  test run.
   * @return outcome
   */
  @javax.annotation.Nullable
  public String getOutcome() {
    return outcome;
  }

  public void setOutcome(@javax.annotation.Nullable String outcome) {
    this.outcome = outcome;
  }


  public TestResultHistoryResponse comment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
    return this;
  }

  /**
   * Test result comment                If any test result related to the test run is linked with autotest, comment will have default value.  Otherwise, the comment equals to the comment of first created test result in the test run
   * @return comment
   */
  @javax.annotation.Nullable
  public String getComment() {
    return comment;
  }

  public void setComment(@javax.annotation.Nullable String comment) {
    this.comment = comment;
  }


  public TestResultHistoryResponse links(@javax.annotation.Nullable List<LinkModel> links) {
    this.links = links;
    return this;
  }

  public TestResultHistoryResponse addLinksItem(LinkModel linksItem) {
    if (this.links == null) {
      this.links = new ArrayList<>();
    }
    this.links.add(linksItem);
    return this;
  }

  /**
   * Test result links                If any test result related to the test run is linked with autotest, link will be equal to the links of last modified test result.  Otherwise, the links equals to the links of first created test result in the test run.
   * @return links
   */
  @javax.annotation.Nullable
  public List<LinkModel> getLinks() {
    return links;
  }

  public void setLinks(@javax.annotation.Nullable List<LinkModel> links) {
    this.links = links;
  }


  public TestResultHistoryResponse startedOn(@javax.annotation.Nullable OffsetDateTime startedOn) {
    this.startedOn = startedOn;
    return this;
  }

  /**
   * Start date time from test result or from test run (if test run new state is Running or Completed state)
   * @return startedOn
   */
  @javax.annotation.Nullable
  public OffsetDateTime getStartedOn() {
    return startedOn;
  }

  public void setStartedOn(@javax.annotation.Nullable OffsetDateTime startedOn) {
    this.startedOn = startedOn;
  }


  public TestResultHistoryResponse completedOn(@javax.annotation.Nullable OffsetDateTime completedOn) {
    this.completedOn = completedOn;
    return this;
  }

  /**
   * End date time from test result or from test run (if test run new state is In progress, Stopped or Completed)
   * @return completedOn
   */
  @javax.annotation.Nullable
  public OffsetDateTime getCompletedOn() {
    return completedOn;
  }

  public void setCompletedOn(@javax.annotation.Nullable OffsetDateTime completedOn) {
    this.completedOn = completedOn;
  }


  public TestResultHistoryResponse duration(@javax.annotation.Nullable Long duration) {
    this.duration = duration;
    return this;
  }

  /**
   * Duration of first created test result in the test run
   * @return duration
   */
  @javax.annotation.Nullable
  public Long getDuration() {
    return duration;
  }

  public void setDuration(@javax.annotation.Nullable Long duration) {
    this.duration = duration;
  }


  public TestResultHistoryResponse createdById(@javax.annotation.Nonnull UUID createdById) {
    this.createdById = createdById;
    return this;
  }

  /**
   * Unique identifier of user who created first test result in the test run
   * @return createdById
   */
  @javax.annotation.Nonnull
  public UUID getCreatedById() {
    return createdById;
  }

  public void setCreatedById(@javax.annotation.Nonnull UUID createdById) {
    this.createdById = createdById;
  }


  public TestResultHistoryResponse modifiedById(@javax.annotation.Nullable UUID modifiedById) {
    this.modifiedById = modifiedById;
    return this;
  }

  /**
   * Unique identifier of user who applied last modification of first test result in the test run
   * @return modifiedById
   */
  @javax.annotation.Nullable
  public UUID getModifiedById() {
    return modifiedById;
  }

  public void setModifiedById(@javax.annotation.Nullable UUID modifiedById) {
    this.modifiedById = modifiedById;
  }


  public TestResultHistoryResponse attachments(@javax.annotation.Nullable List<AttachmentModel> attachments) {
    this.attachments = attachments;
    return this;
  }

  public TestResultHistoryResponse addAttachmentsItem(AttachmentModel attachmentsItem) {
    if (this.attachments == null) {
      this.attachments = new ArrayList<>();
    }
    this.attachments.add(attachmentsItem);
    return this;
  }

  /**
   * Attachments related to the test result                If any test result related to the test run is linked with autotest, attachments will be equal to the attachments of last modified  test result. Otherwise, the attachments equals to the attachments of first created test result in the test run.
   * @return attachments
   */
  @javax.annotation.Nullable
  public List<AttachmentModel> getAttachments() {
    return attachments;
  }

  public void setAttachments(@javax.annotation.Nullable List<AttachmentModel> attachments) {
    this.attachments = attachments;
  }


  public TestResultHistoryResponse workItemVersionId(@javax.annotation.Nullable UUID workItemVersionId) {
    this.workItemVersionId = workItemVersionId;
    return this;
  }

  /**
   * Unique identifier of workitem version related to the first test result in the test run
   * @return workItemVersionId
   */
  @javax.annotation.Nullable
  public UUID getWorkItemVersionId() {
    return workItemVersionId;
  }

  public void setWorkItemVersionId(@javax.annotation.Nullable UUID workItemVersionId) {
    this.workItemVersionId = workItemVersionId;
  }


  public TestResultHistoryResponse workItemVersionNumber(@javax.annotation.Nullable Integer workItemVersionNumber) {
    this.workItemVersionNumber = workItemVersionNumber;
    return this;
  }

  /**
   * Number of workitem version related to the first test result in the test run
   * @return workItemVersionNumber
   */
  @javax.annotation.Nullable
  public Integer getWorkItemVersionNumber() {
    return workItemVersionNumber;
  }

  public void setWorkItemVersionNumber(@javax.annotation.Nullable Integer workItemVersionNumber) {
    this.workItemVersionNumber = workItemVersionNumber;
  }


  public TestResultHistoryResponse launchSource(@javax.annotation.Nullable String launchSource) {
    this.launchSource = launchSource;
    return this;
  }

  /**
   * Get launchSource
   * @return launchSource
   */
  @javax.annotation.Nullable
  public String getLaunchSource() {
    return launchSource;
  }

  public void setLaunchSource(@javax.annotation.Nullable String launchSource) {
    this.launchSource = launchSource;
  }


  public TestResultHistoryResponse failureClassIds(@javax.annotation.Nonnull List<UUID> failureClassIds) {
    this.failureClassIds = failureClassIds;
    return this;
  }

  public TestResultHistoryResponse addFailureClassIdsItem(UUID failureClassIdsItem) {
    if (this.failureClassIds == null) {
      this.failureClassIds = new ArrayList<>();
    }
    this.failureClassIds.add(failureClassIdsItem);
    return this;
  }

  /**
   * Unique identifier of failure classes related to the first test result in the test run
   * @return failureClassIds
   */
  @javax.annotation.Nonnull
  public List<UUID> getFailureClassIds() {
    return failureClassIds;
  }

  public void setFailureClassIds(@javax.annotation.Nonnull List<UUID> failureClassIds) {
    this.failureClassIds = failureClassIds;
  }


  public TestResultHistoryResponse parameters(@javax.annotation.Nullable Map<String, String> parameters) {
    this.parameters = parameters;
    return this;
  }

  public TestResultHistoryResponse putParametersItem(String key, String parametersItem) {
    if (this.parameters == null) {
      this.parameters = new HashMap<>();
    }
    this.parameters.put(key, parametersItem);
    return this;
  }

  /**
   * Parameters of test result
   * @return parameters
   */
  @javax.annotation.Nullable
  public Map<String, String> getParameters() {
    return parameters;
  }

  public void setParameters(@javax.annotation.Nullable Map<String, String> parameters) {
    this.parameters = parameters;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TestResultHistoryResponse testResultHistoryResponse = (TestResultHistoryResponse) o;
    return Objects.equals(this.id, testResultHistoryResponse.id) &&
        Objects.equals(this.createdDate, testResultHistoryResponse.createdDate) &&
        Objects.equals(this.modifiedDate, testResultHistoryResponse.modifiedDate) &&
        Objects.equals(this.userId, testResultHistoryResponse.userId) &&
        Objects.equals(this.testRunId, testResultHistoryResponse.testRunId) &&
        Objects.equals(this.testRunName, testResultHistoryResponse.testRunName) &&
        Objects.equals(this.createdByUserName, testResultHistoryResponse.createdByUserName) &&
        Objects.equals(this.testPlanId, testResultHistoryResponse.testPlanId) &&
        Objects.equals(this.testPlanGlobalId, testResultHistoryResponse.testPlanGlobalId) &&
        Objects.equals(this.testPlanName, testResultHistoryResponse.testPlanName) &&
        Objects.equals(this.configurationName, testResultHistoryResponse.configurationName) &&
        Objects.equals(this.isAutomated, testResultHistoryResponse.isAutomated) &&
        Objects.equals(this.outcome, testResultHistoryResponse.outcome) &&
        Objects.equals(this.comment, testResultHistoryResponse.comment) &&
        Objects.equals(this.links, testResultHistoryResponse.links) &&
        Objects.equals(this.startedOn, testResultHistoryResponse.startedOn) &&
        Objects.equals(this.completedOn, testResultHistoryResponse.completedOn) &&
        Objects.equals(this.duration, testResultHistoryResponse.duration) &&
        Objects.equals(this.createdById, testResultHistoryResponse.createdById) &&
        Objects.equals(this.modifiedById, testResultHistoryResponse.modifiedById) &&
        Objects.equals(this.attachments, testResultHistoryResponse.attachments) &&
        Objects.equals(this.workItemVersionId, testResultHistoryResponse.workItemVersionId) &&
        Objects.equals(this.workItemVersionNumber, testResultHistoryResponse.workItemVersionNumber) &&
        Objects.equals(this.launchSource, testResultHistoryResponse.launchSource) &&
        Objects.equals(this.failureClassIds, testResultHistoryResponse.failureClassIds) &&
        Objects.equals(this.parameters, testResultHistoryResponse.parameters);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, createdDate, modifiedDate, userId, testRunId, testRunName, createdByUserName, testPlanId, testPlanGlobalId, testPlanName, configurationName, isAutomated, outcome, comment, links, startedOn, completedOn, duration, createdById, modifiedById, attachments, workItemVersionId, workItemVersionNumber, launchSource, failureClassIds, parameters);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TestResultHistoryResponse {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    createdDate: ").append(toIndentedString(createdDate)).append("\n");
    sb.append("    modifiedDate: ").append(toIndentedString(modifiedDate)).append("\n");
    sb.append("    userId: ").append(toIndentedString(userId)).append("\n");
    sb.append("    testRunId: ").append(toIndentedString(testRunId)).append("\n");
    sb.append("    testRunName: ").append(toIndentedString(testRunName)).append("\n");
    sb.append("    createdByUserName: ").append(toIndentedString(createdByUserName)).append("\n");
    sb.append("    testPlanId: ").append(toIndentedString(testPlanId)).append("\n");
    sb.append("    testPlanGlobalId: ").append(toIndentedString(testPlanGlobalId)).append("\n");
    sb.append("    testPlanName: ").append(toIndentedString(testPlanName)).append("\n");
    sb.append("    configurationName: ").append(toIndentedString(configurationName)).append("\n");
    sb.append("    isAutomated: ").append(toIndentedString(isAutomated)).append("\n");
    sb.append("    outcome: ").append(toIndentedString(outcome)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("    startedOn: ").append(toIndentedString(startedOn)).append("\n");
    sb.append("    completedOn: ").append(toIndentedString(completedOn)).append("\n");
    sb.append("    duration: ").append(toIndentedString(duration)).append("\n");
    sb.append("    createdById: ").append(toIndentedString(createdById)).append("\n");
    sb.append("    modifiedById: ").append(toIndentedString(modifiedById)).append("\n");
    sb.append("    attachments: ").append(toIndentedString(attachments)).append("\n");
    sb.append("    workItemVersionId: ").append(toIndentedString(workItemVersionId)).append("\n");
    sb.append("    workItemVersionNumber: ").append(toIndentedString(workItemVersionNumber)).append("\n");
    sb.append("    launchSource: ").append(toIndentedString(launchSource)).append("\n");
    sb.append("    failureClassIds: ").append(toIndentedString(failureClassIds)).append("\n");
    sb.append("    parameters: ").append(toIndentedString(parameters)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("createdDate");
    openapiFields.add("modifiedDate");
    openapiFields.add("userId");
    openapiFields.add("testRunId");
    openapiFields.add("testRunName");
    openapiFields.add("createdByUserName");
    openapiFields.add("testPlanId");
    openapiFields.add("testPlanGlobalId");
    openapiFields.add("testPlanName");
    openapiFields.add("configurationName");
    openapiFields.add("isAutomated");
    openapiFields.add("outcome");
    openapiFields.add("comment");
    openapiFields.add("links");
    openapiFields.add("startedOn");
    openapiFields.add("completedOn");
    openapiFields.add("duration");
    openapiFields.add("createdById");
    openapiFields.add("modifiedById");
    openapiFields.add("attachments");
    openapiFields.add("workItemVersionId");
    openapiFields.add("workItemVersionNumber");
    openapiFields.add("launchSource");
    openapiFields.add("failureClassIds");
    openapiFields.add("parameters");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("createdDate");
    openapiRequiredFields.add("modifiedDate");
    openapiRequiredFields.add("userId");
    openapiRequiredFields.add("isAutomated");
    openapiRequiredFields.add("createdById");
    openapiRequiredFields.add("failureClassIds");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TestResultHistoryResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TestResultHistoryResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TestResultHistoryResponse is not found in the empty JSON string", TestResultHistoryResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TestResultHistoryResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TestResultHistoryResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TestResultHistoryResponse.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (!jsonObj.get("userId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `userId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("userId").toString()));
      }
      if ((jsonObj.get("testRunId") != null && !jsonObj.get("testRunId").isJsonNull()) && !jsonObj.get("testRunId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `testRunId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("testRunId").toString()));
      }
      if ((jsonObj.get("testRunName") != null && !jsonObj.get("testRunName").isJsonNull()) && !jsonObj.get("testRunName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `testRunName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("testRunName").toString()));
      }
      if ((jsonObj.get("createdByUserName") != null && !jsonObj.get("createdByUserName").isJsonNull()) && !jsonObj.get("createdByUserName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createdByUserName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createdByUserName").toString()));
      }
      if ((jsonObj.get("testPlanId") != null && !jsonObj.get("testPlanId").isJsonNull()) && !jsonObj.get("testPlanId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `testPlanId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("testPlanId").toString()));
      }
      if ((jsonObj.get("testPlanName") != null && !jsonObj.get("testPlanName").isJsonNull()) && !jsonObj.get("testPlanName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `testPlanName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("testPlanName").toString()));
      }
      if ((jsonObj.get("configurationName") != null && !jsonObj.get("configurationName").isJsonNull()) && !jsonObj.get("configurationName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `configurationName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("configurationName").toString()));
      }
      if ((jsonObj.get("outcome") != null && !jsonObj.get("outcome").isJsonNull()) && !jsonObj.get("outcome").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `outcome` to be a primitive type in the JSON string but got `%s`", jsonObj.get("outcome").toString()));
      }
      if ((jsonObj.get("comment") != null && !jsonObj.get("comment").isJsonNull()) && !jsonObj.get("comment").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `comment` to be a primitive type in the JSON string but got `%s`", jsonObj.get("comment").toString()));
      }
      if (jsonObj.get("links") != null && !jsonObj.get("links").isJsonNull()) {
        JsonArray jsonArraylinks = jsonObj.getAsJsonArray("links");
        if (jsonArraylinks != null) {
          // ensure the json data is an array
          if (!jsonObj.get("links").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `links` to be an array in the JSON string but got `%s`", jsonObj.get("links").toString()));
          }

          // validate the optional field `links` (array)
          for (int i = 0; i < jsonArraylinks.size(); i++) {
            LinkModel.validateJsonElement(jsonArraylinks.get(i));
          };
        }
      }
      if (!jsonObj.get("createdById").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createdById` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createdById").toString()));
      }
      if ((jsonObj.get("modifiedById") != null && !jsonObj.get("modifiedById").isJsonNull()) && !jsonObj.get("modifiedById").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `modifiedById` to be a primitive type in the JSON string but got `%s`", jsonObj.get("modifiedById").toString()));
      }
      if (jsonObj.get("attachments") != null && !jsonObj.get("attachments").isJsonNull()) {
        JsonArray jsonArrayattachments = jsonObj.getAsJsonArray("attachments");
        if (jsonArrayattachments != null) {
          // ensure the json data is an array
          if (!jsonObj.get("attachments").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `attachments` to be an array in the JSON string but got `%s`", jsonObj.get("attachments").toString()));
          }

          // validate the optional field `attachments` (array)
          for (int i = 0; i < jsonArrayattachments.size(); i++) {
            AttachmentModel.validateJsonElement(jsonArrayattachments.get(i));
          };
        }
      }
      if ((jsonObj.get("workItemVersionId") != null && !jsonObj.get("workItemVersionId").isJsonNull()) && !jsonObj.get("workItemVersionId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `workItemVersionId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("workItemVersionId").toString()));
      }
      if ((jsonObj.get("launchSource") != null && !jsonObj.get("launchSource").isJsonNull()) && !jsonObj.get("launchSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `launchSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("launchSource").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("failureClassIds") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("failureClassIds").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `failureClassIds` to be an array in the JSON string but got `%s`", jsonObj.get("failureClassIds").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TestResultHistoryResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TestResultHistoryResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TestResultHistoryResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TestResultHistoryResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<TestResultHistoryResponse>() {
           @Override
           public void write(JsonWriter out, TestResultHistoryResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TestResultHistoryResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TestResultHistoryResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TestResultHistoryResponse
   * @throws IOException if the JSON string is invalid with respect to TestResultHistoryResponse
   */
  public static TestResultHistoryResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TestResultHistoryResponse.class);
  }

  /**
   * Convert an instance of TestResultHistoryResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

